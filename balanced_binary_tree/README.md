# 平衡二叉树（AVL树）实现

## 平衡二叉树的基本概念

平衡二叉树是一种特殊的二叉搜索树，它通过在插入和删除操作时自动调整树的结构，确保树的高度始终保持在较低水平，从而保证了搜索、插入和删除操作的时间复杂度为O(log n)。

### AVL树的定义

AVL树是由G.M. Adelson-Velsky和E.M. Landis于1962年提出的一种平衡二叉搜索树。它的特点是：

- 是一棵二叉搜索树
- 每个节点的左右子树高度差（平衡因子）的绝对值不超过1
- 平衡因子 = 左子树高度 - 右子树高度

## 平衡因子计算

对于AVL树中的每个节点，平衡因子的计算如下：

```
平衡因子 = 左子树高度 - 右子树高度
```

当平衡因子的绝对值大于1时，树就失去了平衡，需要通过旋转操作来重新平衡。

## 旋转操作

AVL树通过四种旋转操作来维持平衡：

### 1. 左旋（Left Rotation）

当右子树的高度过高时（平衡因子 < -1），需要进行左旋操作。

### 2. 右旋（Right Rotation）

当左子树的高度过高时（平衡因子 > 1），需要进行右旋操作。

### 3. 左右旋（Left-Right Rotation）

当左子树的右子树高度过高时（平衡因子 > 1且左子节点平衡因子 < 0），需要先对左子节点进行左旋，再对当前节点进行右旋。

### 4. 右左旋（Right-Left Rotation）

当右子树的左子树高度过高时（平衡因子 < -1且右子节点平衡因子 > 0），需要先对右子节点进行右旋，再对当前节点进行左旋。

## 插入操作原理

1. 按照二叉搜索树的规则插入新节点
2. 更新从插入节点到根节点路径上所有节点的高度
3. 检查每个节点的平衡因子
4. 如果发现不平衡，根据情况选择合适的旋转操作进行调整

## 删除操作原理

1. 按照二叉搜索树的规则删除节点
2. 更新从删除节点的父节点到根节点路径上所有节点的高度
3. 检查每个节点的平衡因子
4. 如果发现不平衡，根据情况选择合适的旋转操作进行调整

## 时间复杂度分析

- 搜索：O(log n)
- 插入：O(log n)
- 删除：O(log n)
- 空间复杂度：O(n)

## 代码使用说明

### 基本操作

```python
from avl_tree import AVLTree

# 创建AVL树实例
avl = AVLTree()

# 插入节点
avl.insert(10)
avl.insert(5)
avl.insert(15)

# 查找节点
result = avl.search(10)  # 返回节点对象，如果不存在返回None

# 删除节点
avl.delete(10)

# 遍历操作
print(avl.inorder())   # 中序遍历
print(avl.preorder())  # 前序遍历
print(avl.postorder()) # 后序遍历
```

### 测试示例

代码中包含了一个测试示例，演示了插入、查找、删除和遍历操作的使用方法。

## 代码结构

- `AVLNode` 类：表示AVL树的节点，包含键值、左右子节点和高度属性
- `AVLTree` 类：实现AVL树的主要操作，包括插入、删除、查找和遍历

## 总结

AVL树是一种高效的平衡二叉搜索树，通过自动调整树的结构，确保了操作的时间复杂度为O(log n)。它在需要频繁进行搜索、插入和删除操作的场景中表现出色，是一种非常重要的数据结构。
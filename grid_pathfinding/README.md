# 网格寻路算法实现与比较

本项目实现了几种经典的网格寻路算法，并提供了性能比较测试脚本。

## 实现的算法

1. **广度优先搜索 (BFS)**
   - 总是找到最短路径
   - 时间复杂度: O(V+E)，其中V是节点数，E是边数
   - 空间复杂度: O(V)

2. **深度优先搜索 (DFS)**
   - 不一定找到最短路径
   - 时间复杂度: O(V+E)
   - 空间复杂度: O(V)

3. **Dijkstra算法**
   - 用于带权图的最短路径查找，在无权图中退化为BFS
   - 时间复杂度: O((V+E)logV) (使用优先队列实现)
   - 空间复杂度: O(V)

4. **A*算法**
   - 结合了Dijkstra算法和启发式搜索
   - 使用曼哈顿距离作为启发函数
   - 时间复杂度: 取决于启发函数的质量，理想情况下接近O(E)
   - 空间复杂度: O(V)

## 项目结构

```
grid_pathfinding/
├── pathfinding.py    # 寻路算法核心实现
├── test_pathfinding.py  # 测试脚本
└── README.md         # 项目说明文档
```

## 使用方法

### 运行测试脚本

```bash
python test_pathfinding.py
```

### 测试结果说明

测试脚本会输出：
1. 初始网格地图
2. 所有算法的性能比较，包括：
   - 路径长度
   - 运行时间（毫秒）
   - 访问节点数
   - 最大内存使用
   - 是否找到路径
3. 最快算法和最节省节点算法
4. 最佳路径的可视化

## 网格表示

- `0`: 可通行区域
- `1`: 障碍物
- `S`: 起点
- `E`: 终点
- `*`: 找到的路径

## 自定义网格

你可以在`test_pathfinding.py`文件中修改：
- `EXAMPLE_GRID`: 自定义网格地图
- `START`: 起点坐标
- `END`: 终点坐标

## 算法性能比较

| 算法 | 路径长度 | 运行时间(ms) | 访问节点数 | 最大内存使用 | 是否找到路径 |
|------|----------|--------------|------------|--------------|--------------|
| BFS  | 18       | 0.012        | 35         | 55           | 是           |
| DFS  | 45       | 0.008        | 46         | 55           | 是           |
| Dijkstra | 18    | 0.025        | 35         | 145          | 是           |
| A*   | 18       | 0.015        | 21         | 145          | 是           |

（以上结果为示例，实际运行可能因环境不同而有所差异）

## 结论

- **最短路径保证**: BFS、Dijkstra和A*算法都能找到最短路径，而DFS通常找到较长路径
- **速度**: 对于简单网格，DFS可能最快，但不保证最短路径
- **效率**: A*算法通常访问最少的节点，因为它使用了启发式函数引导搜索
- **适用场景**:
  - 追求最短路径: BFS、Dijkstra、A*
  - 快速找到任意路径: DFS
  - 大规模网格: A*（效率最高）
  - 带权图: Dijkstra、A*

## 扩展建议

1. 添加更多启发式函数（如欧几里得距离、切比雪夫距离）
2. 实现双向搜索
3. 支持8方向移动（当前仅支持4方向）
4. 添加动态障碍物支持
5. 实现更高级的算法如JPS (Jump Point Search) 或 IDA* (Iterative Deepening A*)

## 许可证

MIT
